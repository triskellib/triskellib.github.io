{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Triskel","text":""},{"location":"#theory","title":"Theory","text":"<p>Triskel's layout algorithm is based on a divide and conquer approach using SESE regions.</p> <p>The graph is split into it's SESE regions, then each region is laid out using Sugiyama Layered graph drawing.</p> <p>This approach yields graphs with significantly less edge crossings and clearer layouts.</p> <p>These results were presented at the Workshop on Binary Analysis Research 2025 (paper, presentation).</p>  A flow graph split into SESE regions  <p> More theory</p>"},{"location":"#screenshots","title":"Screenshots","text":"\u276e \u276f"},{"location":"#using-the-api","title":"Using the API","text":"<p>Triskel includes an easy to use API for drawing flow graphs in your applications.</p> <p>It's available for:</p> <ul> <li>C++</li> <li>Python</li> <li>Java</li> </ul> C++PythonJava <pre><code>#include &lt;triskel/triskel.hpp&gt;\n\nint main(void) {\n    auto builder  = triskel::make_layout_builder();\n\n    const auto n1 = builder-&gt;make_node(\"Hello\");\n    const auto n2 = builder-&gt;make_node(\"World\");\n    builder-&gt;make_edge(n1, n2)\n\n    auto renderer = triskel::make_svg_renderer();\n    builder-&gt;measure_nodes(renderer)\n    const auto layout   = builder-&gt;build();\n\n    layout-&gt;render_and_save(*renderer, \"./out.svg\");\n\n    return 0;\n}\n</code></pre> <pre><code>from pytriskel.pytriskel import *\n\nbuilder = make_layout_builder()\n\n# Build the graph\nn1 = builder.make_node(\"Hello\")\nn2 = builder.make_node(\"World\")\nbuilder.make_edge(n1, n2)\n\n# Measure node size using font size\npng_renderer = make_png_renderer()\nbuilder.measure_nodes(png_renderer)\n\n# Export an image\nlayout = builder.build()\nlayout.save(png_renderer, \"out.png\")\n</code></pre> <pre><code>import jtriskel.*;\n\npublic class Main {\n    static {\n        System.loadLibrary(\"jtriskel\");\n    }\n\n    public static void main(String[] args) {\n        try {\n            LayoutBuilder builder = jtriskel.make_layout_builder();\n            ExportingRenderer png_renderer = jtriskel.make_png_renderer();\n\n            long n1 = builder.make_node(\"Hello\");\n            long n2 = builder.make_node(\"World\");\n\n            long e = builder.make_edge(n1, n2);\n\n            builder.measure_nodes(png_renderer);\n            CFGLayout layout = builder.build();\n            builder.delete();\n\n            layout.render_and_save_s(png_renderer, \"./out.png\");\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p> API</p>"},{"location":"#get-in-touch","title":"Get in touch","text":"<p> Join our discord</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#architecture","title":"Architecture","text":"<p>Triskel uses a two step process for its API.</p> <ul> <li>First, a builder is used to construct the graph (creating nodes, edges, setting node dimensions etc...).</li> <li>Then, a layout for the provided graph can be constructed. The layout provides access to information such as a node's coordinates, or an edge's waypoints.</li> </ul> <p>An optional third step is available: the renderer, it is used to go from coordinates to a visual representation (image or GUI component).</p>"},{"location":"api/#coordinate-system","title":"Coordinate system","text":"<p>Coordinates, when given as a pair correspond to <code>(x, y)</code>. For example <code>(4, 2)</code> would be a point with x coordinate 4 and y coordinate 2.</p> <p>Coordinates in Triskel use floats, and have no units.</p> <p>Coordinates in Triskel correspond to the coordinates of the Top Left corner of an element. For example, in the diagram, the coordinates of <code>A</code> would be <code>(1, 0)</code> and those of <code>B</code> would be <code>(0, 2)</code>.</p> <p>Triskel will always return a graph where the minimum x and y values are 0. As you can see in the diagram, the top left corner of the bounding box of the graph is in <code>(0, 0)</code>. This means that all coordinates provided by Triskel are positive.</p>"},{"location":"api/#waypoints","title":"Waypoints","text":"<p>Triskel models edges as a sequence of segments. This sequence of segments is represented as a list of waypoints.</p> <p>In the diagram, the edge <code>A -&gt; D</code> would be represented as the sequence of waypoints <code>A, B, C, D</code> (more precisely, using the coordinates <code>(4, 1), (4, 2), (1, 2), (1, 3)</code>).</p> <p>Notes</p> <ul> <li>Notice that the order is important, the final coordinate is where the arrow is pointing to.</li> <li>The inner coordinates in the list are used to draw two segments (for example <code>B</code> is used for <code>A-B</code> and for <code>B-C</code>), they are not duplicated.</li> </ul>"},{"location":"api/#components","title":"Components","text":""},{"location":"api/#builder","title":"Builder","text":"<p>The builder is used to construct a graph.</p> <p>It can be built using the <code>make_layout_builder</code> method:</p> C++PythonJava <pre><code>auto builder  = triskel::make_layout_builder();\n</code></pre> <pre><code>builder = make_layout_builder()\n</code></pre> <pre><code>LayoutBuilder builder = jtriskel.make_layout_builder();\n</code></pre>"},{"location":"api/#creating-nodes","title":"Creating nodes","text":"<p>Nodes can be added to the graph with the <code>make_node</code> method.</p> <p>This method can be used to create a node with a given label or with given dimensions.</p> <p>It returns the id of the created node.</p> <p>This id is necessary to later access the coordinate of this node, or to create an edge with this node.</p> <p>Root</p> <p>The first node that is created must be the <code>root</code> of the graph.</p> C++PythonJava <pre><code>// Creates a node\nconst auto n1  = builder-&gt;make_node();\n\n// Creates a node with a label\nconst auto n2  = builder-&gt;make_node(\"label\");\n\n// Creates a node with a given size\n// Here, a width of 1 and a height of 2\nconst auto n3  = builder-&gt;make_node(1, 2);\n</code></pre> <pre><code># Creates a node\nn1  = builder.make_node()\n\n# Creates a node with a label\nn2  = builder.make_node(\"label\")\n\n# Creates a node with a given size\n# Here, a width of 1 and a height of 2\nn3  = builder.make_node(1, 2)\n</code></pre> <pre><code>// Creates a node\nlong n1 = builder.make_node();\n\n// Creates a node with a label\nlong n2  = builder.make_node(\"label\");\n\n// Creates a node with a given size\n// Here, a width of 1 and a height of 2\nlong n3  = builder.make_node(1, 2);\n</code></pre>"},{"location":"api/#creating-edges","title":"Creating edges","text":"<p>Edges can be added to the graph with the <code>make_edge</code> method.</p> <p>This method takes the id of the origin and destination nodes, and returns the id of the edge;</p> C++PythonJava <pre><code>// Creates nodes\nconst auto n1  = builder-&gt;make_node();\nconst auto n2  = builder-&gt;make_node();\n\n// Creates an edge\nconst auto e  = builder-&gt;make_edge(n1, n2);\n</code></pre> <pre><code># Creates nodes\nn1  = builder-&gt;make_node()\nn2  = builder-&gt;make_node()\n\n# Creates an edge\ne  = builder-&gt;make_edge(n1, n2)\n</code></pre> <pre><code>// Creates nodes\nlong n1  = builder.make_node();\nlong n2  = builder.make_node();\n\n// Creates an edge\nlong e  = builder.make_edge(n1, n2);\n</code></pre>"},{"location":"api/#creating-the-layout","title":"Creating the layout","text":"<p>A builder can be used to create a layout using the <code>build</code> method.</p> C++PythonJava <pre><code>const auto layout = builder-&gt;build();\n</code></pre> <pre><code>layout = builder.build()\n</code></pre> <pre><code>CFGLayout layout = builder.build();\n</code></pre> <p>Lifetimes</p> <p>Triskel assumes that the builder is destroyed after a call to <code>build</code> is performed.</p>"},{"location":"api/#dot-notation","title":"Dot notation","text":"<p>Mainly for debug reasons, it is possible to export the graph contained in the builder to Graphviz's dot notation using the method <code>graphviz</code>.</p> C++PythonJava <pre><code>// Creates nodes\nconst auto n1  = builder-&gt;make_node();\nconst auto n2  = builder-&gt;make_node();\n\n// Creates an edge\nconst auto e  = builder-&gt;make_edge(n1, n2);\n\n// Export the graph to dot notation\nstd::cout &lt;&lt; builder-&gt;graphviz();\n</code></pre> <pre><code># Creates nodes\nn1  = builder.make_node()\nn2  = builder.make_node()\n\n# Creates an edge\ne  = builder.make_edge(n1, n2)\n\n# Export the graph to dot notation\nprint(builder.graphviz())\n</code></pre> <pre><code>// Creates nodes\nlong n1  = builder.make_node();\nlong n2  = builder.make_node();\n\n// Creates an edge\nlong e  = builder.make_edge(n1, n2);\n\n// Export the graph to dot notation\nSystem.out.println(builder.graphviz());\n</code></pre> <p>The expected output for this graph would be: <pre><code>digraph G {\nn1\nn0\nn0 [shape=square]\nn0 -&gt; n1\n}\n</code></pre></p> <p>Identifying the root</p> <p>The root of the graph is square for easy identification.</p>"},{"location":"api/#using-a-renderer","title":"Using a renderer","text":"<p>If your nodes have labels, we need to use a renderer to calculate the size of those nodes. This can be done after all the nodes are built using the <code>measure_nodes</code> method.</p> C++PythonJava <pre><code>builder-&gt;measure_nodes(renderer);\n</code></pre> <pre><code>builder.measure_nodes(renderer)\n</code></pre> <pre><code>builder.measure_nodes(renderer);\n</code></pre> <p>No renderer, no problem</p> <p>If no renderer is provided, Triskel assumes that a character is 1 large and a line is 1 tall.</p>"},{"location":"api/#settings","title":"Settings","text":"<p>A couple settings can be changed in the builder:</p> <ul> <li><code>x gutter</code>: This corresponds to the minimum horizontal distance between two nodes, or a node and a vertical segment. It defaults to 50.</li> <li><code>y gutter</code>: This corresponds to the minimum vertical distance between a horizontal segment and a node. It defaults to 40.</li> <li><code>edge height</code>: This corresponds to the minimum vertical distance between two horizontal segments. It defaults to 30.</li> </ul> <p></p> <p>In the diagram, distances determined by:</p> <ul> <li><code>x gutter</code> are represented in blue.</li> <li><code>y gutter</code> are represented in red.</li> <li><code>edge height</code> are represented in green.</li> </ul> C++PythonJava <pre><code>builder-&gt;set_x_gutter(1.0F);\nbuilder-&gt;set_y_gutter(2.0F);\nbuilder-&gt;set_edge_height(3.0F);\n</code></pre> <pre><code>builder.set_x_gutter(1.0)\nbuilder.set_y_gutter(2.0)\nbuilder.set_edge_height(3.0)\n</code></pre> <pre><code>builder.set_x_gutter(1.0F);\nbuilder.set_y_gutter(2.0F);\nbuilder.set_edge_height(3.0F);\n</code></pre>"},{"location":"api/#layout","title":"Layout","text":"<p>The layout contains the coordinates necessary to draw the graph.</p>"},{"location":"api/#node-coordinates","title":"Node coordinates","text":"<p>Using a node's id, you can retrieve its coordinates.</p> C++PythonJava <pre><code>const auto n1 = builder-&gt;make_node();\n// [...]\nconst auto pt = layout-&gt;get_coords(n1);\nstd::cout &lt;&lt; \"x: \" &lt;&lt; pt.x &lt;&lt; \" y: \" &lt;&lt; pt.y;\n</code></pre> <pre><code>n1 = builder.make_node()\n# [...]\npt = layout.get_coords(n1)\nprint(f\"x: {pt.x} y: {pt.y}\")\n</code></pre> <pre><code>long n1 = builder.make_node();\n// [...]\nPoint pt = layout.get_coords(n1);\nSystem.out.println(\"x: \" + pt.x + \" y: \" + pt.y);\n</code></pre>"},{"location":"api/#edge-waypoints","title":"Edge waypoints","text":"<p>Using a edge's id, you can retrieve its waypoints.</p> C++PythonJava <pre><code>const auto e = builder-&gt;make_edge(n1, n2);\n// [...]\nconst auto&amp; waypoints = layout-&gt;waypoints(e);\n</code></pre> <pre><code>e = builder.make_edge(n1, n2)\n# [...]\nwaypoints = layout.get_waypoints(e)\n</code></pre> <pre><code>long e = builder.make_edge(n1, n2);\n// [...]\nList&lt;Point&gt; waypoints = layout.get_waypoints(e);\n</code></pre>"},{"location":"api/#node-dimensions","title":"Node dimensions","text":"<p>We can access a node's dimension with the <code>get_node_height</code> and <code>get_node_width</code> methods. This is especially important for nodes whose dimensions were calculated by a renderer.</p> C++PythonJava <pre><code>const auto n1 = builder-&gt;make_node();\n// [...]\nconst auto width = layout-&gt;get_node_width(n1);\nconst auto height = layout-&gt;get_node_height(n1);\n</code></pre> <pre><code>n1 = builder.make_node()\n# [...]\nwidth = layout.get_node_width(n1)\nheight = layout.get_node_height(n1)\n</code></pre> <pre><code>long n1 = builder.make_node();\n// [...]\nfloat width = layout.get_node_width(n1);\nfloat height = layout.get_node_height(n1);\n</code></pre>"},{"location":"api/#graph-dimensions","title":"Graph dimensions","text":"<p>We can access the graph's dimension with the <code>get_height</code> and <code>get_width</code> methods.</p> C++PythonJava <pre><code>const auto width = layout-&gt;get_width();\nconst auto height = layout-&gt;get_height();\n</code></pre> <pre><code>width = layout.get_width()\nheight = layout.get_height()\n</code></pre> <pre><code>float width = layout.get_width();\nfloat height = layout.get_height();\n</code></pre>"},{"location":"api/#renderers","title":"Renderers","text":"<p>Renders are used for drawing a layout. They are used with the <code>render</code> or <code>render_and_save</code> methods.</p> <p>The ImGui provides the ImguiRenderer and Cairo extensions provides the PNGRenderer and SVGRenderer.</p>"},{"location":"api/#other-methods","title":"Other methods","text":""},{"location":"api/#version","title":"Version","text":"<p>The function <code>git_version</code> allows you to identify which version of Triskel you are using.</p> C++PythonJava <pre><code>triskel::git_version();\n</code></pre> <pre><code>git_version()\n</code></pre> <pre><code>jtriskel.git_version();\n</code></pre>"},{"location":"api/#extensions","title":"Extensions","text":""},{"location":"api/#cairo","title":"Cairo","text":"<p>The Cairo extension provides two renderers for saving layouts to images.</p> <p>These renderers use the <code>render_and_save</code> method.</p> C++PythonJava <pre><code>auto builder  = triskel::make_layout_builder();\n// [...]\nauto renderer = triskel::make_svg_renderer();\nconst auto layout   = builder-&gt;build();\nlayout-&gt;render_and_save(*renderer, \"./out.svg\");\n</code></pre> <pre><code>builder  = make_layout_builder();\n# [...]\nrenderer = make_svg_renderer();\nlayout   = builder-&gt;build();\nlayout-&gt;render_and_save(renderer, \"./out.svg\");\n</code></pre> <pre><code>LayoutBuilder builder  = jtriskel.make_layout_builder();\n// [...]\nExportingRenderer renderer = jtriskel.make_svg_renderer();\nCFGLayout layout   = builder-&gt;build();\nlayout-&gt;render_and_save(renderer, \"./out.svg\");\n</code></pre>"},{"location":"api/#pngrenderer","title":"PNGRenderer","text":"<p>The PNG renderer is used to save layouts to PNG images. It is created with the <code>make_png_renderer</code> method.</p>"},{"location":"api/#svgrenderer","title":"SVGRenderer","text":"<p>The SVG renderer is used to save layouts to SVG images. It is created with the <code>make_svg_renderer</code> method.</p>"},{"location":"plugins/","title":"Plugins","text":"<p>We integrated Triskel into binary analysis engines.</p> <p>Limitation</p> <p>The current plugin implementation do not perform any checks on the graph size which can lead to freezes / crashes.</p> <p>WIP</p>"},{"location":"plugins/#binary-ninja","title":"Binary Ninja","text":""},{"location":"plugins/#screenshots","title":"Screenshots","text":"<p> \u276e \u276f </p>"},{"location":"plugins/#installation","title":"Installation","text":"<p>This plugin is currently unavailable to the public!</p>"},{"location":"plugins/#usage","title":"Usage","text":""},{"location":"plugins/#changing-the-layout-engine","title":"Changing the layout engine","text":"<p>To pick the new layout engines provided by Triskel, go to <code>Edit &gt; Settings &gt; Rendering &gt; graph &gt; Default Graph Layout</code>, and switch the engine to Triskel.</p> <p></p>"},{"location":"plugins/#options","title":"Options","text":"<p>Triskel's layout comes with different compactness options to suit your personal preference. These options only change spacing between blocks.</p>"},{"location":"plugins/#reporting-a-bug","title":"Reporting a bug","text":"<p>You can access Triskel's build information for reporting a bug by going to <code>Plugins &gt; Triskel Version</code>.</p> <p></p> <p>Shout out</p> <p>Huge shout out to Binary Ninja for being very helpful!</p>"},{"location":"plugins/#ghidra","title":"Ghidra","text":""},{"location":"plugins/#screenshots_1","title":"Screenshots","text":"\u276e \u276f"},{"location":"plugins/#installation_1","title":"Installation","text":"<p>Go to the ghidra extension repo, and download the latest release.</p> <p>You can then install it like a regular Ghidra extension</p> Installing a Ghidra Extension <p>When starting Ghidra, Go to <code>File &gt; Install Extension</code>. </p> <p>Then click on the green plus at the top left and select the downloaded zip. </p> <p>Finally, restart Ghidra.</p>"},{"location":"plugins/#usage_1","title":"Usage","text":"<p>Start by opening a function's graph view.</p> <p></p>"},{"location":"plugins/#changing-the-layout-engine_1","title":"Changing the layout engine","text":"<p>On the dropdown to select a layout engine, select Triskel.</p> <p></p>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Platform</p> <p>Triskel was only tested on Linux. If you are using other platforms, this might or might not work..</p>"},{"location":"quickstart/#python","title":"Python","text":""},{"location":"quickstart/#pip","title":"Pip","text":"<p>Triskel is available as a pip package: pytriskel</p> <pre><code>$ pip install pytriskel\n</code></pre>"},{"location":"quickstart/#compile-a-wheel","title":"Compile a wheel","text":"<p>Triskel uses pybind11 to generate its Python bindings.</p> <p>From the <code>/bindings/python</code> directory run</p> <pre><code>$ pip wheel .\n</code></pre> <p>Compiling a shared library</p> <p>If you want to compile just the shared library, rather than build a python wheel, you need to compile triskel with the cmake <code>BUILD_PYTHON_BINDINGS</code> flag set to <code>ON</code>.</p>"},{"location":"quickstart/#c","title":"C++","text":"<p>Triskel can be built using <code>CMake</code>.</p> <pre><code>$ cmake -B build\n$ cmake --build build\n</code></pre>"},{"location":"quickstart/#dependencies","title":"Dependencies","text":"<p>Triskel with minimum options only depends on libfmt.</p> <p>To see a complete list of dependencies when all options are enabled, check out the dependencies script used in the Fedora Docker image.</p>"},{"location":"quickstart/#compilation-options","title":"Compilation options","text":""},{"location":"quickstart/#extensions","title":"Extensions","text":"<p>Triskel comes with a few extensions to facilitate integration with other tools.</p>"},{"location":"quickstart/#enable_cairo","title":"<code>ENABLE_CAIRO</code>","text":"<p>This option adds a two renderers for exporting graphs to PNGs and SVGs.</p> <p>It requires Cairo as an additional dependency.</p> <p>Note</p> <p>This option was enabled when building the Python and Java bindings.</p>"},{"location":"quickstart/#enable_llvm","title":"<code>ENABLE_LLVM</code>","text":"<p>This option adds a method to the API to convert LLVM functions to triskel graphs.</p> <p>It requires LLVM as an additional dependency.</p>"},{"location":"quickstart/#enable_imgui","title":"<code>ENABLE_IMGUI</code>","text":"<p>This option adds a renderer for displaying graphs in ImGui.</p> <p>It requires ImGui as an additional dependency.</p>"},{"location":"quickstart/#example-binaries","title":"Example binaries","text":"<p>Triskel ships with a few example binaries</p>"},{"location":"quickstart/#build_gui","title":"<code>BUILD_GUI</code>","text":"<p>Builds a simple graph explorer using ImGui. This binary comes with a very rudimentary x86 disassembler for visualizing CFGs in binaries. It is also able to display LLVM functions.</p>"},{"location":"quickstart/#build_img","title":"<code>BUILD_IMG</code>","text":"<p>Builds a simple binary that lays out the CFG of an LLVM Function and saves it to a PNG.</p>"},{"location":"quickstart/#build_bench","title":"<code>BUILD_BENCH</code>","text":"<p>Builds the binary used for benchmarking, it lays out functions in LLVM <code>.ll</code> files without rendering them. It can be optionally passed a function name to only lay out a single function.</p> <p>Note</p> <p>This binary only provides debug and benchmarking info, it will not show you any graphs.</p>"},{"location":"quickstart/#bindings","title":"Bindings","text":"<p>These options are used for building bindings for other languages, refer to the section of the corresponding language to see how to build bindings for it.</p> <ul> <li><code>BUILD_JAVA_BINDINGS</code></li> <li><code>BUILD_PYTHON_BINDINGS</code></li> <li><code>BUILD_WASM</code></li> </ul>"},{"location":"quickstart/#development","title":"Development","text":"<p>Two options are available for dev builds, <code>ENABLE_LINTING</code> and <code>ENABLE_TESTING</code>.</p>"},{"location":"quickstart/#javascript-wasm","title":"Javascript (WASM)","text":"<p>Triskel uses emscripten to generate WASM.</p> <p>To generate web assembly (WASM) from Triskel use <code>emcmake</code>.</p> <pre><code>emcmake cmake -B build -DCMAKE_TOOLCHAIN_FILE=$(WASM_TOOLCHAIN) -DBUILD_WASM=ON\ncmake --build build\n</code></pre> <p>We used <code>emsdk</code> version <code>4.0.5</code>.</p>"},{"location":"quickstart/#java","title":"Java","text":"<p>Triskel uses swig to generate Java bindings.</p> <p>Java binding only require to pass the appropriate CMake flag: <code>DBUILD_JAVA_BINDINGS</code></p> <pre><code>cmake -B build -DBUILD_JAVA_BINDINGS=ON\ncmake --build build\n</code></pre> <p> API</p>"},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#our-paper","title":"Our paper","text":"<p>Triskel was presented at the Workshop on Binary Analysis Research 2025.</p> <p>You can find our paper and presentation.</p>"},{"location":"theory/#cite-triskel","title":"Cite Triskel","text":"<pre><code>@inproceedings{royer:hal-04996939,\n  AUTHOR = {Royer, Jack and Tronel, Fr{\\'e}d{\\'e}ric and Vin{\\c c}ont, Ya{\\\"e}lle},\n  TITLE = {{Towards Better CFG Layouts}},\n  BOOKTITLE = {{Workshop on Binary Analysis Research 2025}},\n  ADDRESS = {San Diego (CA), United States},\n  MONTH = Feb,\n  YEAR = {2025},\n  URL = {https://www.ndss-symposium.org/wp-content/uploads/bar2025-final11.pdf},\n  DOI = {10.14722/bar.2025.23011},\n}\n</code></pre>"},{"location":"theory/#other-papers","title":"Other papers","text":"<p>These papers were very influential for writing Triskel (large parts of Triskel are implementations of other algorithms).</p> <ul> <li>A Technique for Drawing Directed Graphs, Gansner, Koutsofios, North, Vo</li> <li>Fast and Simple Horizontal Coordinate Assignment, Brandes, K\u00f6pf</li> <li>Methods for Visual Understanding of Hierarchical System Structures, Sugiyama, Tagawa, Toda</li> </ul>"}]}